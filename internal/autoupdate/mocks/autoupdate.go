// Code generated by MockGen. DO NOT EDIT.
// Source: internal/autoupdate/autoupdate.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"
	time "time"

	gomock "github.com/golang/mock/gomock"
	githubclt "github.com/simplesurance/goordinator/internal/githubclt"
	zap "go.uber.org/zap"
)

// MockGithubClient is a mock of GithubClient interface.
type MockGithubClient struct {
	ctrl     *gomock.Controller
	recorder *MockGithubClientMockRecorder
}

// MockGithubClientMockRecorder is the mock recorder for MockGithubClient.
type MockGithubClientMockRecorder struct {
	mock *MockGithubClient
}

// NewMockGithubClient creates a new mock instance.
func NewMockGithubClient(ctrl *gomock.Controller) *MockGithubClient {
	mock := &MockGithubClient{ctrl: ctrl}
	mock.recorder = &MockGithubClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGithubClient) EXPECT() *MockGithubClientMockRecorder {
	return m.recorder
}

// CombinedStatus mocks base method.
func (m *MockGithubClient) CombinedStatus(ctx context.Context, owner, repo, ref string) (string, time.Time, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CombinedStatus", ctx, owner, repo, ref)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(time.Time)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// CombinedStatus indicates an expected call of CombinedStatus.
func (mr *MockGithubClientMockRecorder) CombinedStatus(ctx, owner, repo, ref interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CombinedStatus", reflect.TypeOf((*MockGithubClient)(nil).CombinedStatus), ctx, owner, repo, ref)
}

// CreateIssueComment mocks base method.
func (m *MockGithubClient) CreateIssueComment(ctx context.Context, owner, repo string, issueOrPRNr int, comment string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateIssueComment", ctx, owner, repo, issueOrPRNr, comment)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateIssueComment indicates an expected call of CreateIssueComment.
func (mr *MockGithubClientMockRecorder) CreateIssueComment(ctx, owner, repo, issueOrPRNr, comment interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateIssueComment", reflect.TypeOf((*MockGithubClient)(nil).CreateIssueComment), ctx, owner, repo, issueOrPRNr, comment)
}

// ListPullRequests mocks base method.
func (m *MockGithubClient) ListPullRequests(ctx context.Context, owner, repo, state, sort, sortDirection string) githubclt.PRIterator {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListPullRequests", ctx, owner, repo, state, sort, sortDirection)
	ret0, _ := ret[0].(githubclt.PRIterator)
	return ret0
}

// ListPullRequests indicates an expected call of ListPullRequests.
func (mr *MockGithubClientMockRecorder) ListPullRequests(ctx, owner, repo, state, sort, sortDirection interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListPullRequests", reflect.TypeOf((*MockGithubClient)(nil).ListPullRequests), ctx, owner, repo, state, sort, sortDirection)
}

// PullRequestIsApproved mocks base method.
func (m *MockGithubClient) PullRequestIsApproved(ctx context.Context, owner, repo string, prNumber int) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PullRequestIsApproved", ctx, owner, repo, prNumber)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PullRequestIsApproved indicates an expected call of PullRequestIsApproved.
func (mr *MockGithubClientMockRecorder) PullRequestIsApproved(ctx, owner, repo, prNumber interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PullRequestIsApproved", reflect.TypeOf((*MockGithubClient)(nil).PullRequestIsApproved), ctx, owner, repo, prNumber)
}

// UpdateBranch mocks base method.
func (m *MockGithubClient) UpdateBranch(ctx context.Context, owner, repo string, pullRequestNumber int) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateBranch", ctx, owner, repo, pullRequestNumber)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateBranch indicates an expected call of UpdateBranch.
func (mr *MockGithubClientMockRecorder) UpdateBranch(ctx, owner, repo, pullRequestNumber interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateBranch", reflect.TypeOf((*MockGithubClient)(nil).UpdateBranch), ctx, owner, repo, pullRequestNumber)
}

// MockRetryer is a mock of Retryer interface.
type MockRetryer struct {
	ctrl     *gomock.Controller
	recorder *MockRetryerMockRecorder
}

// MockRetryerMockRecorder is the mock recorder for MockRetryer.
type MockRetryerMockRecorder struct {
	mock *MockRetryer
}

// NewMockRetryer creates a new mock instance.
func NewMockRetryer(ctrl *gomock.Controller) *MockRetryer {
	mock := &MockRetryer{ctrl: ctrl}
	mock.recorder = &MockRetryerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRetryer) EXPECT() *MockRetryerMockRecorder {
	return m.recorder
}

// Run mocks base method.
func (m *MockRetryer) Run(arg0 context.Context, arg1 func(context.Context) error, arg2 []zap.Field) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Run", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// Run indicates an expected call of Run.
func (mr *MockRetryerMockRecorder) Run(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockRetryer)(nil).Run), arg0, arg1, arg2)
}
